#include "Operator.hpp"
#include "Basic.hpp"
#include "TypeInfo.hpp"
#include "Utils.hpp"
#include "Value.hpp"

#include <cassert>
#include <cstring>
#include <map>
#include <ostream>
#include <random>
#include <set>
#include <string>

// This header file would be auto-generated by
// scripts/GenerateOperatorComputeHeaders.py
#include "AutoGenComputeOp.h"
#include "softfloat_types.h"

namespace RIF {

int placeholderIndex;

static std::string getNewPlaceholderName() {
  return "\tplaceholder" + std::to_string(placeholderIndex++);
}

static std::string getUniqueName(std::string name) {
  static std::map<std::string, int> nameCount;
  return name + '_' + std::to_string(nameCount[name]++);
}

void InitializeOp::generateData() {
  // Please go to Graph::generateData() for the data generation call
  assert(false && "This function shall not be triggered");
}

template <typename T>
void generateOneDInitCCode(std::ostream &os, ValueBase *value,
                           const std::string &dataType) {
  auto oned = static_cast<T *>(value);
  auto length = oned->length;
  if (isIntegral(value->dt)) {
    os << "\t" << dataType << " tmp[] = {";
  } else {
    if (value->dt == DataTypeEnum::Float16_t) {
      os << "\t" << "uint16_t tmp[] = {";
    } else if (value->dt == DataTypeEnum::Float32_t) {
      os << "\t" << "uint32_t tmp[] = {";
    } else if (value->dt == DataTypeEnum::Float64_t) {
      os << "\t" << "uint64_t tmp[] = {";
    } else {
      assert(false && "Unhandled type");
    }
  }

  auto raw = oned->raw;
  for (int i = 0; i < length; ++i) {
    if (value->dt == DataTypeEnum::Int8_t) {
      os << std::to_string((int8_t)raw[i]);
    } else if (value->dt == DataTypeEnum::Int16_t) {
      os << std::to_string((int16_t)raw[i]);
    } else if (value->dt == DataTypeEnum::Int32_t) {
      os << std::to_string((int32_t)raw[i]);
    } else if (value->dt == DataTypeEnum::Int64_t) {
      os << std::to_string((int64_t)raw[i]) << "ll";
    } else if (value->dt == DataTypeEnum::Uint8_t) {
      os << std::to_string((uint8_t)raw[i]);
    } else if (value->dt == DataTypeEnum::Uint16_t) {
      os << std::to_string((uint16_t)raw[i]);
    } else if (value->dt == DataTypeEnum::Uint32_t) {
      os << std::to_string((uint32_t)raw[i]) << "u";
    } else if (value->dt == DataTypeEnum::Uint64_t) {
      os << std::to_string((uint64_t)raw[i]) << "ull";
    } else if (value->dt == DataTypeEnum::Float16_t) {
      os << std::to_string((uint16_t)raw[i]);
    } else if (value->dt == DataTypeEnum::Float32_t) {
      os << std::to_string((uint32_t)raw[i]) << "u";
    } else if (value->dt == DataTypeEnum::Float64_t) {
      os << std::to_string((uint64_t)raw[i]) << "ull";
    } else if (value->dt == DataTypeEnum::Ptrdiff_t) {
      os << std::to_string((long)raw[i]) << "ll";
    } else if (value->dt == DataTypeEnum::Size_t) {
      os << std::to_string((unsigned long)raw[i]) << "ull";
    } else {
      assert(false && "Unkown dataType");
    }

    os << ",";
  }
  os << "};\n";
  os << "for (int i=0; i<" << length << ";++i) {";
  if (!isIntegral(value->dt)) {
    if (value->dt == DataTypeEnum::Float16_t) {
      os << "union { uint16_t u16; " << dataType << " f; } converter;\n";
      os << "converter.u16 = tmp[i];\n";
    } else if (value->dt == DataTypeEnum::Float32_t) {
      os << "union { uint32_t u32; " << dataType << " f; } converter;\n";
      os << "converter.u32 = tmp[i];\n";
    } else if (value->dt == DataTypeEnum::Float64_t) {
      os << "union { uint64_t u64; " << dataType << " f; } converter;\n";
      os << "converter.u64 = tmp[i];\n";
    } else {
      assert(false && "Unhandled type");
    }
    os << oned->id << "[i] = converter.f;\n";
  } else {
    os << oned->id << "[i] = tmp[i];\n";
  }
  os << "}\n";
}

template <typename T>
void generateScalarInitCCode(std::ostream &os, ValueBase *value,
                             const std::string &dataType) {
  auto scalar = static_cast<T *>(value);
  assert(scalar->length == 1);
  auto raw = scalar->raw;
  os << " // generaed by library/Operator.cpp generateScalarInitCCode\n\t";
  if (isIntegral(value->dt)) {
    os << dataType << " tmp = ";
  } else {
    if (value->dt == DataTypeEnum::Float16_t) {
      os << "uint16_t tmp = ";
    } else if (value->dt == DataTypeEnum::Float32_t) {
      os << "uint32_t tmp = ";
    } else if (value->dt == DataTypeEnum::Float64_t) {
      os << "uint64_t tmp = ";
    } else {
      assert(false && "Unhandled type");
    }
  }
  if (value->dt == DataTypeEnum::Int8_t) {
    os << std::to_string((int8_t)*raw);
  } else if (value->dt == DataTypeEnum::Int16_t) {
    os << std::to_string((int16_t)*raw);
  } else if (value->dt == DataTypeEnum::Int32_t) {
    os << std::to_string((int32_t)*raw);
  } else if (value->dt == DataTypeEnum::Int64_t) {
    os << std::to_string((int64_t)*raw) << "ll";
  } else if (value->dt == DataTypeEnum::Uint8_t) {
    os << std::to_string((uint8_t)*raw);
  } else if (value->dt == DataTypeEnum::Uint16_t) {
    os << std::to_string((uint16_t)*raw);
  } else if (value->dt == DataTypeEnum::Uint32_t) {
    os << std::to_string((uint32_t)*raw) << "u";
  } else if (value->dt == DataTypeEnum::Uint64_t) {
    os << std::to_string((uint64_t)*raw) << "ull";
  } else if (value->dt == DataTypeEnum::Float16_t) {
    os << std::to_string((uint16_t)*raw);
  } else if (value->dt == DataTypeEnum::Float32_t) {
    os << std::to_string((uint32_t)*raw) << "u";
  } else if (value->dt == DataTypeEnum::Float64_t) {
    os << std::to_string((uint64_t)*raw) << "ull";
  } else if (value->dt == DataTypeEnum::Ptrdiff_t) {
    os << std::to_string((long)*raw) << "ll";
  } else if (value->dt == DataTypeEnum::Size_t) {
    os << std::to_string((unsigned long)*raw) << "ull";
  } else {
    assert(false && "Unkown dataType");
  }

  os << ";\n";

  if (!isIntegral(value->dt)) {
    if (value->dt == DataTypeEnum::Float16_t) {
      os << "union { uint16_t u16; " << dataType << " f; } converter;\n";
      os << "converter.u16 = tmp;\n";
    } else if (value->dt == DataTypeEnum::Float32_t) {
      os << "union { uint32_t u32; " << dataType << " f; } converter;\n";
      os << "converter.u32 = tmp;\n";
    } else if (value->dt == DataTypeEnum::Float64_t) {
      os << "union { uint64_t u64; " << dataType << " f; } converter;\n";
      os << "converter.u64 = tmp;\n";
    } else {
      assert(false && "Unhandled type");
    }
    os << scalar->id << " = converter.f;\n";
  } else {
    os << scalar->id << " = tmp;\n";
  }
}

void InitializeOp::generateCCode(std::ostream &os) {
  auto value = outputs[0];
  auto typeInfo = value->typeInfo;
  int trigger = 0;
#define CUSTOM_ONE_D_TYPE(CUSTOM_NAME, DATA_TYPE, DATA_WIDTH, DATA_CLASS,      \
                          MIN_VALUE, MAX_VALUE)                                \
  if (value->type == CustomValType::OneD##CUSTOM_NAME) {                       \
    generateOneDInitCCode<OneD##CUSTOM_NAME##Val>(os, value, #DATA_TYPE);      \
    ++trigger;                                                                 \
  }
#include "CustomValue.def"
#undef CUSTOM_ONE_D_TYPE
#undef CUSTOM_SCALAR_TYPE
#define CUSTOM_SCALAR_TYPE(CUSTOM_NAME, DATA_TYPE, DATA_WIDTH, DATA_CLASS,     \
                           MIN_VALUE, MAX_VALUE)                               \
  if (value->type == CustomValType::Scalar##CUSTOM_NAME) {                     \
    generateScalarInitCCode<Scalar##CUSTOM_NAME##Val>(os, value, #DATA_TYPE);  \
    ++trigger;                                                                 \
  }
#include "CustomValue.def"
#undef CUSTOM_ONE_D_TYPE
#undef CUSTOM_SCALAR_TYPE

  if (trigger != 1) {
    std::cerr
        << "InitializeOp::generateCCode: Value not recognized correctly\n";
    exit(1);
  }
}

static std::string getRawPointerString(std::ostream &os, ValueBase *value,
                                       bool isWrite = false) {
  std::string holder = getNewPlaceholderName();
  if (isOneDValue(value))
    os << value->dataTypeID << " *" << holder << " = " << value->id << "; // vector \n";
  else if (isScalarValue(value)) {
    if (isWrite)
      os << value->dataTypeID << " *" << holder << " = &" << value->id << "; // scalar \n";
    else
      os << value->dataTypeID << " " << holder << " = " << value->id << "; // scalar not write \n";
  } else
      assert(false); // unreachable

  return holder;
}

static std::string getVectorFromConstant(std::ostream &os, int constant,
                                         const TypeInfo &typeInfo) {
  std::string result = getNewPlaceholderName();
  os << typeInfo.vectorTypeName << " " << result
     << (typeInfo.typeClass == FLOAT ? " = __riscv_vfmv_v_f_" : " = __riscv_vmv_v_x_")
     << typeInfo.shortVectorTypeName << "(" << constant << ", "
     << typeInfo.setvlmaxTypeName << "());\n";
  return result;
}
static std::string getVectorFromVector(std::ostream &os,
                                       const std::string &vecPlaceholder,
                                       const TypeInfo &typeInfo) {
  std::string result = getNewPlaceholderName();
  os << typeInfo.vectorTypeName << " " << result << " = __riscv_vmv_v_v_"
     << typeInfo.shortVectorTypeName << "(" << vecPlaceholder << ", "
     << typeInfo.setvlmaxTypeName << "());\n";
  return result;
}

static std::map<int, int> log2LUT = {{1, 0},  {2, 1},  {4, 2}, {8, 3},
                                     {16, 4}, {32, 5}, {64, 6}};
size_t getBooleanSew(const TypeInfo &typeInfo) {
  return 64 >> (typeInfo.lmul - (log2LUT[typeInfo.sew.to_int()] - 3));
}
size_t getBooleanLmul(const TypeInfo &typeInfo) {
  return 6 - log2LUT[getBooleanSew(typeInfo)];
}

static std::string getVmsetMaskReg(std::ostream &os, const TypeInfo &typeInfo) {
  std::string result = getNewPlaceholderName();
  int booleanSew = getBooleanSew(typeInfo);
  os << "vbool" << std::to_string(booleanSew) << "_t " << result
     << " = __riscv_vmset_m_b" << std::to_string(booleanSew) << "("
     << typeInfo.setvlmaxTypeName << "());\n";
  return result;
}

static std::string getVmclrMaskReg(std::ostream &os, const TypeInfo &typeInfo) {
  std::string result = getNewPlaceholderName();
  int booleanSew = getBooleanSew(typeInfo);
  os << "vbool" << std::to_string(booleanSew) << "_t " << result
     << " = __riscv_vmclr_m_b" << std::to_string(booleanSew) << "("
     << typeInfo.setvlmaxTypeName << "());\n";
  return result;
}

static std::string getFlippedMaskReg(std::ostream &os,
                                     const std::string &maskReg,
                                     const TypeInfo &typeInfo) {
  int booleanSew = getBooleanSew(typeInfo);
  std::string vecMaskSet = getVmsetMaskReg(os, typeInfo);
  std::string flippedMaskReg = getNewPlaceholderName();
  os << "vbool" << booleanSew << "_t " << flippedMaskReg << " = __riscv_vmandn_mm_b"
     << booleanSew << "(" << vecMaskSet << ", " << maskReg << ", vl);\n";
  return flippedMaskReg;
}

std::string getFirst(std::ostream &os) {
  std::string first = getNewPlaceholderName();
  os << "int32_t " << first << " = -1;\n";
  return first;
}

static void setVLMax(std::ostream &os, const TypeInfo &typeInfo) {
  os << "int vlmax = " << typeInfo.setvlmaxTypeName << "();\n";
}

static void setVL(std::ostream &os, const std::string &counter,
                  const TypeInfo &typeInfo, bool isBoolean = false) {
  if (isBoolean) {
    int booleanSew = getBooleanSew(typeInfo);
    int booleanLmul = getBooleanLmul(typeInfo);
    std::string lmulStr = LMUL_STR(static_cast<LmulType>(booleanLmul));
    os << "vl = __riscv_vsetvl_e8" << lmulStr << "(" << counter << ");\n";
  } else
    os << "vl = " << typeInfo.setvlTypeName << "(" << counter << ");\n";
}

std::string loadOneDToVector(std::ostream &os, ValueBase *value,
                             const std::string &holder, OperatorBase *op) {
  auto typeInfo = *value->typeInfo;
  std::string resultVec;
  if (value->type == OneDBool) {
    std::string vecHolder = "vec_" + value->id;
    resultVec = getUniqueName("mask_" + value->id);

    size_t booleanSew =
        (op->opAttr & WideningOperation || op->opAttr & NarrowingOperation)
            ? getBooleanSew(*getVs2(op)->typeInfo)
            : getBooleanSew(*op->typeInfo);
    size_t booleanLmul =
        (op->opAttr & WideningOperation || op->opAttr & NarrowingOperation)
            ? getBooleanLmul(*getVs2(op)->typeInfo)
            : getBooleanLmul(*op->typeInfo);

    std::string lmulStr = LMUL_STR(static_cast<LmulType>(booleanLmul));

    os << "vint8" << lmulStr << "_t " << vecHolder << " = __riscv_vle8_v_i8" << lmulStr
       << "(" << holder << ", vl);\n";
    os << "\tvbool" << booleanSew << "_t " << resultVec << " = __riscv_vmseq_vx_i8"
       << lmulStr << "_b" << booleanSew << "(" << vecHolder << ", 1, vl);\n";
  } else { // normal
    resultVec = getUniqueName("vec_" + value->id);
    os << "\t" << typeInfo.vectorTypeName << " " << resultVec << " = __riscv_vle"
       << typeInfo.sew.to_string() << "_v_" << typeInfo.shortVectorTypeName
       << "(" << holder << ", vl);\n";
  }
  return resultVec;
}

static void genIntrinsicFuncSuffix(std::ostream &os, OperatorBase *op,
                                   const std::vector<std::string> &args) {
  const OperatorAttrT &opAttr = op->opAttr;
  if (op->opAttr & FRM)
    os << "_rm";
  if (isExplicitPolicy(op)) {
    os << "_";
    if (hasTA(op)) {
      assert(!hasTU(op));
      os << "ta";
    }
    if (hasTU(op)) {
      assert(!hasTA(op));
      os << "tu";
    }
    if (hasMA(op)) {
      assert(hasMask(op) && !hasMU(op));
      os << "ma";
    }
    if (hasMU(op)) {
      assert(hasMask(op) && !hasMA(op));
      os << "mu";
    }
    if (opAttr & ReductionOperation && hasMask(op)) {
      os << "m";
    }

    os << "(";
  } else {
    if (hasMask(op))
      os << "_m (";
    else if (hasNonmask(op))
      os << "(";
    else {
      std::cerr << "Masking attribute for operator is not set correctly.\n";
      exit(1);
    }
  }


  if ((op->opAttr & FRM) || (op->opAttr & VXRM))
  {
    for (size_t i = 0; i < args.size() - 1; i++){
        os << args[i] << ", ";
    }
  }
  else
  {
    for (auto arg : args)
    {
      os << arg << ", ";
    }

  }


  if (opAttr & OperatorAttr::HaveVLParameter) {
    if (op->opAttr & FRM)
      os << "frm, vl);\n";
    else if (op->opAttr & VXRM)
      os << "vxrm, vl);\n";
    else
      os << "vl);\n";
  } else if (opAttr & OperatorAttr::NoVLParameter)
    os << ");\n";
  else {
    std::cerr << "VL attribute for operator is not set correctly.\n";
    exit(1);
  }
}

static void genReductionOpString(std::ostream &os, OperatorBase *op,
                                 const std::string &vecReduction,
                                 const std::vector<std::string> &args) {
  const std::string &instrisicFuncPrefix = op->typeID;
  ValueBase *vd = getVd(op);
  ValueBase *vs2 = getVs2(op);
  assert(vd != nullptr);
  assert(vs2 != nullptr);

  os << vecReduction << " = __riscv_" << instrisicFuncPrefix << "_"
     << vs2->typeInfo->shortVectorTypeName << "_"
     << vd->typeInfo->shortVectorTypeName;

  genIntrinsicFuncSuffix(os, op, args);
  os << "\n\t";
}

std::string genOpString(std::ostream &os, OperatorBase *op,
                        const std::vector<std::string> &args,
                        ValueBase *output) {
  const auto &typeInfo = *op->typeInfo;
  const auto &opAttr = op->opAttr;
  const auto &instrisicFuncPrefix = op->typeID;

  std::string resultVec = "";

  if (!(opAttr & VoidOperation)) { // non void operation
    resultVec = getUniqueName("vec_" + output->id);
    if (output->type == CustomValType::OneDBool)
      os << "vbool" << getBooleanSew(typeInfo) << "_t " << resultVec << " = __riscv_";
    else
      os << output->typeInfo->vectorTypeName << " " << resultVec << " = ";
  }

  if (output->type == CustomValType::OneDBool) {
    int booleanSew = getBooleanSew(typeInfo);
    std::string vectorTypeName = "vbool" + std::to_string(booleanSew) + "_t";

    if (opAttr & LogicalMaskOperation)
      os << op->typeID << "_b" << getBooleanSew(typeInfo);
    else {
      ValueBase *vs2 = getVs2(op);
      std::string shortVectorTypeName = vs2->typeInfo->shortVectorTypeName +
                                        "_b" +
                                        std::to_string(getBooleanSew(typeInfo));
      os << op->typeID << "_" << shortVectorTypeName;
    }
  } else // normal operator
    os << "__riscv_" << instrisicFuncPrefix << "_" << output->typeInfo->shortVectorTypeName;

  genIntrinsicFuncSuffix(os, op, args);

  os << "\t";
  return resultVec;
}

void storeVectorToOneD(std::ostream &os, const std::string rawBase,
                       const std::string vec, ValueBase *value) {
  if (value->type == OneDBool) { // store bool into int8_t
    auto op = value->inputs[0];
    size_t booleanSew = getBooleanSew(*op->typeInfo);

    LmulType booleanLmul = static_cast<LmulType>(log2LUT[64 / booleanSew]);
    auto typeInfo = TypeInfo::create(booleanLmul, SewType{8}, SIGNED_INT);
    os << "{\n";
    os << "\tsize_t vlmax = " << typeInfo->setvlmaxTypeName << "();\n\t";
    os << "\t" <<typeInfo->vectorTypeName << " zero = "
       << "__riscv_vmv_v_x_" << typeInfo->shortVectorTypeName << "(0, vlmax);\n\t";
    os << "\t" << typeInfo->vectorTypeName << " vec_store = "
       << "__riscv_vmerge_vxm_" << typeInfo->shortVectorTypeName << "(" 
       << "zero, 1, "
       << vec << ", " << "vl);\n\t";
    os << "__riscv_vse8_v_" << typeInfo->shortVectorTypeName << "(" << rawBase << ", "
       << "vec_store, vl);\n\t";
    os << "}\n\t";
  } else {
    auto typeInfo = *value->typeInfo;
    os << "__riscv_vse" << typeInfo.sew.to_string() << "_v_"
       << typeInfo.shortVectorTypeName << "(" << rawBase << ", " << vec
       << ", vl);\n\t";
  }
}

static void storeVectorToOneD(std::ostream &os, const std::string &vecM,
                              const std::string rawBase,
                              const std::string vecVal, ValueBase *value) {
  os << "// generated by library/Operator.cpp storeVectorToOneD\n\t";
  if (value->type == OneDBool) { // store bool into int8_t
    assert(false && "FIXME: implement this in the future");
  } else {
    auto typeInfo = *value->typeInfo;
    os << "__riscv_vse" << typeInfo.sew.to_string() << "_v_"
       << typeInfo.shortVectorTypeName << "_m(" << vecM << ", " << rawBase
       << ", " << vecVal << ", vl);\n\t";
  }
}

static void storeVectorToScalar(std::ostream &os, const std::string rawBase,
                                const std::string &vec,
                                const TypeInfo &typeInfo) {
  os << "*" << rawBase << "= "
     << (typeInfo.typeClass == FLOAT ? "__riscv_vfmv_f_s_" : "__riscv_vmv_x_s_")
     << typeInfo.shortVectorTypeName << "_" << typeInfo.shortScalarTypeName
     << "(" << vec << ");\n\t";
}

static void storeScalarToScalar(std::ostream &os, const std::string &lhs,
                                const std::string &rhs) {
  os << "*" << lhs << " = " << rhs << "; \n\t";
}

static std::string getOpSuffix(OperatorBase *op) {
  std::string s = "_";
  if (hasTA(op))
    s += "ta";
  if (hasTU(op))
    s += "tu";
  if (hasMA(op))
    s += "ma";
  if (hasMU(op))
    s += "mu";
  if (s == "_" && hasMask(op))
    s += "m";
  if (s == "_")
    s = "";
  return s;
}

void incrementRawPointerByVLEN(std::ostream &os, std::string ptrID) {
  os << ptrID << " += vl;\n";
}

CodeGenForOperator::CodeGenForOperator(std::ostream &os, OperatorBase *op,
                                       TypeInfo &typeInfo, size_t length)
    : os(os), op(op), vlTypeInfo(typeInfo), loopLength(length) {}

void CodeGenForOperator::getRawPointers(std::vector<ValueBase *> inputs,
                                        ValueBase *output) {
  for (ValueBase *input : inputs)
    opInputs.push_back({getRawPointerString(os, input), input});
  opOutput = {getRawPointerString(os, output), output};
}

std::vector<std::string> CodeGenForOperator::getIntrinsicArguments() {
  std::vector<std::string> ret;

  for (auto &input : opInputs) {
    std::string &rawID = input.first;
    ValueBase *value = input.second;

    if (isOneDValue(value)) {
      std::string loadVec = loadOneDToVector(os, value, rawID, op);
      ret.push_back(loadVec);
    } else {
      ret.push_back(rawID);
    }
  }

  return ret;
}

void CodeGenForOperator::incrementRawPointerByVLEN() {
  for (auto &input : opInputs) {
    std::string &rawID = input.first;
    ValueBase *value = input.second;
    if (isScalarValue(value))
      continue;
    RIF::incrementRawPointerByVLEN(os, rawID);
  }
  if (isOneDValue(opOutput.second))
    RIF::incrementRawPointerByVLEN(os, opOutput.first);
}

void CodeGenForOperator::storeResult(std::string opResult) {
  storeVectorToOneD(os, opOutput.first, opResult, opOutput.second);
}

std::string CodeGenForOperator::getCounter(std::ostream &os, size_t length) {
  std::string counter = getNewPlaceholderName();
  os << "int " << counter << " = " << length << ";\n";
  os << "\n";
  return counter;
}

void CodeGenForOperator::getLoopStart(std::ostream &os, std::string counter) {
  os << "for (size_t vl; " << counter << " > 0; " << counter << " -= vl) {\n";
}

void CodeGenForOperator::getLoopEnd(std::ostream &os) { 
  os << "}\n"; 
}

void CodeGenForOperator::getVL(std::string counter) {
  setVL(os, counter, vlTypeInfo);
}

void CodeGenForOperator::generateSingleOperatorCode() {
  auto output = op->outputs[0];
  getRawPointers(op->inputs, output);
  os << "\n";
  std::string counter = CodeGenForOperator::getCounter(os, loopLength);
  CodeGenForOperator::getLoopStart(os, counter);
  {
    if (haveTailPolicy(op)) {
      os << "vl = 2;\n";
      os << "size_t tail_vl = 1;\n";
    } else {
      getVL(counter);
    }
    std::vector<std::string> args = getIntrinsicArguments();
    os << "\n";
    auto opResult = genOpString(os, op, args, output);
    os << "\n";
    storeResult(opResult);
    os << "\n";
    incrementRawPointerByVLEN();
  }
  CodeGenForOperator::getLoopEnd(os);
}

struct CodeGenForReductionOperator : CodeGenForOperator {
  CodeGenForReductionOperator() = delete;
  CodeGenForReductionOperator(std::ostream &os, OperatorBase *op,
                              TypeInfo &typeInfo, size_t length)
      : CodeGenForOperator(os, op, typeInfo, length) {}

  void getRawPointers(std::vector<ValueBase *> inputs, ValueBase *output) {
    for (ValueBase *input : inputs)
      opInputs.push_back({getRawPointerString(os, input), input});
    opOutput = {getRawPointerString(os, output, true), output};
  }
  void generateSingleOperatorCode() {
    auto output = op->outputs[0];
    getRawPointers(op->inputs, output);

    std::string counter = CodeGenForOperator::getCounter(os, loopLength);

    std::string vecZero = getVectorFromConstant(os, 0, *output->typeInfo);
    std::string vecReduction =
        getVectorFromVector(os, vecZero, *output->typeInfo);
    if (hasTA(op) || hasTU(op)) {
      os << "// This function initializes the output elements according to\n"
            "// its\n"
            "// tail policy and\n"
            "// the reason doing so is to maintain VLA style.\n"
            "// For ta policy, it initializes the value to all 1's, for tu it\n"
            "// initializes to values of merge instead. E.g.\n"
            "// in[5]:  [1, 1, 2, 2, 3]\n"
            "// out[5]: [0, 0, 0, 0, 0] (global value is initialized to 0)\n"
            "// vl:     4\n"
            "// If we apply redsum_ta(out, in, vl), We want the result to be:\n"
            "// [9, -1, -1, -1, -1].\n"
            "// However, the vl is only 4, so it might result in something\n"
            "// like:\n"
            "// [6, -1, -1, -1, 3],\n"
            "// but we want to maintain the output consistent as it's in VLA\n"
            "// style,\n"
            "// so one of the most convinent way to do so is to initialize\n"
            "// the\n"
            "// tail value in the beginning\n"
            "// before performing actual computing, namely, getting into the\n"
            "// loop.\n";
      if (hasTA(op)) {
        os << "memset(" << output->id << ", 0xff, sizeof(" << output->id
           << "));\n";
      } else if (hasTU(op)) {
        auto &merge = hasMask(op) ? op->inputs[1]->id : op->inputs[0]->id;
        os << "memcpy(" << output->id << ", " << merge << ", sizeof("
           << output->id << "));\n";
      }
    }

    CodeGenForOperator::getLoopStart(os, counter);
    {
      getVL(counter);

      std::vector<std::string> loaded = getIntrinsicArguments();
      std::vector<std::string> args;
      if (loaded.size() == 1) {
        if (hasTA(op)) {
          args = {loaded[0], vecReduction};
        } else {
          args = {vecReduction, loaded[0], vecReduction};
        }
      } else if (loaded.size() == 2) {
        if (hasTA(op) || hasTU(op)) { // tu or tam
          args = {loaded[0], loaded[1], vecReduction};
        } else { // normal _m
          args = {loaded[0], loaded[1]};
        }
      } else if (loaded.size() == 3) { // tum
        args = {loaded[0], loaded[1], loaded[2]};
      }

      genReductionOpString(os, op, vecReduction, args);
      incrementRawPointerByVLEN();
    }
    CodeGenForOperator::getLoopEnd(os);

    storeVectorToScalar(os, getRawPointerString(os, output, true), vecReduction,
                        *output->typeInfo);
  }
};

struct CodeGenForVcpop : CodeGenForOperator {
  CodeGenForVcpop() = delete;
  CodeGenForVcpop(std::ostream &os, OperatorBase *op, TypeInfo &typeInfo,
                  size_t length)
      : CodeGenForOperator(os, op, typeInfo, length) {}

  void getRawPointers(std::vector<ValueBase *> inputs, ValueBase *output) {
    for (ValueBase *input : inputs)
      opInputs.push_back({getRawPointerString(os, input), input});
    opOutput = {getRawPointerString(os, output, true), output};
  }
  void genVcpopOpString(const std::string &popcountStr,
                        const std::vector<std::string> &args) {
    os << popcountStr << " += __riscv_vcpop_m_b" << getBooleanSew(*op->typeInfo);
    genIntrinsicFuncSuffix(os, op, args);
  }
  std::string getPopcountCounter() {
    std::string popcountCounter = getNewPlaceholderName();
    os << "uint32_t " << popcountCounter << " = 0;\n";
    return popcountCounter;
  }
  void generateSingleOperatorCode() {
    auto output = op->outputs[0];
    getRawPointers(op->inputs, output);
    std::string counter = CodeGenForOperator::getCounter(os, loopLength);
    std::string popcount = getPopcountCounter();
    CodeGenForOperator::getLoopStart(os, counter);
    {
      getVL(counter);
      std::vector<std::string> args = getIntrinsicArguments();
      genVcpopOpString(popcount, args);
      incrementRawPointerByVLEN();
    }
    CodeGenForOperator::getLoopEnd(os);
    storeScalarToScalar(os, opOutput.first, popcount);
  }
};

struct CodeGenForVfirst : CodeGenForOperator {
  CodeGenForVfirst() = delete;
  CodeGenForVfirst(std::ostream &os, OperatorBase *op, TypeInfo &typeInfo,
                   size_t length)
      : CodeGenForOperator(os, op, typeInfo, length) {}

  std::string getLengthCounter() {
    std::string lengthCounter = getNewPlaceholderName();
    os << "uint32_t " << lengthCounter << " = 0;\n";
    return lengthCounter;
  }

  void getRawPointers(std::vector<ValueBase *> inputs, ValueBase *output) {
    for (ValueBase *input : inputs)
      opInputs.push_back({getRawPointerString(os, input), input});
    opOutput = {getRawPointerString(os, output, true), output};
  }
  void genVfirstOpString(const std::string &first,
                         const std::vector<std::string> &args) {
    os << first << " = __riscv_vfirst_m_b" << getBooleanSew(*op->typeInfo);
    genIntrinsicFuncSuffix(os, op, args);
  }
  void getLoopStart(const std::string &counter, const std::string &first,
                    const std::string &lengthCounter) {
    os << "for (size_t vl = 0; " << first << " == -1 && " << counter << " > 0; "
       << counter << " -= vl) {\n";
    os << lengthCounter << " += vl;\n";
  }
  void getLoopEnd(const std::string &first, const std::string &lengthCounter) {
    os << "}\n";
    os << "if (" << first << " != -1) " << first << " += " << lengthCounter
       << ";\n";
  }

  void generateSingleOperatorCode() {
    auto output = op->outputs[0];
    getRawPointers(op->inputs, output);
    std::string counter = CodeGenForOperator::getCounter(os, loopLength);
    std::string first = getFirst(os);
    std::string lengthCounter = getLengthCounter();
    getLoopStart(counter, first, lengthCounter);
    {
      getVL(counter);
      std::vector<std::string> args = getIntrinsicArguments();
      genVfirstOpString(first, args);
      incrementRawPointerByVLEN();
    }
    getLoopEnd(first, lengthCounter);
    storeScalarToScalar(os, opOutput.first, first);
  }
};

struct CodeGenForVmsbfVmsifVmsof : CodeGenForOperator {
  CodeGenForVmsbfVmsifVmsof() = delete;
  CodeGenForVmsbfVmsifVmsof(std::ostream &os, OperatorBase *op,
                            TypeInfo &typeInfo, size_t length)
      : CodeGenForOperator(os, op, typeInfo, length) {}

  std::string getLoopEndStoreMask(std::vector<std::string> args) {
    std::string vecM = args[0];
    std::string vecMO = args[1];
    std::string vecStored = getNewPlaceholderName();
    int booleanSew = getBooleanSew(vlTypeInfo);
    os << " // generated by library/Operator.cpp getLoopEndStoreMask \n\t";
    os << "vbool" << booleanSew << "_t " << vecStored << " = ";
    if (hasMA(op)) {
      os << "__riscv_vmnot_m_b" << booleanSew << "(" << vecM << ", vl);\n";
    } else {
      os << "__riscv_vmandn_mm_b" << booleanSew << "(" << vecMO << ", " << vecM
         << ", vl);\n";
    }
    return vecStored;
  }
  void getLoopStart(const std::string &counter, const std::string &first) {
    os << "for (size_t vl = 0; " << counter << " > 0 && " << first << " == -1; "
       << counter << " -= vl) {\n\t";
  }
  void getLoopEnd(const std::string &counter) {
    os << "}\n";
    os << "for (size_t vl;" << counter << " > 0; " << counter << " -= vl) {\n\t";
    {
      getVL(counter);
      if (!hasMask(op)) {
        std::string vecMaskClr = getVmclrMaskReg(os, vlTypeInfo);
        storeVectorToOneD(os, opOutput.first, vecMaskClr, opOutput.second);
      } else {
        auto args = getIntrinsicArguments();
        std::string vecStored = getLoopEndStoreMask(args);
        storeVectorToOneD(os, opOutput.first, vecStored, opOutput.second);
      }
      incrementRawPointerByVLEN();
    }
    os << "}\n";
  }
  void updateFirst(const std::string &first, std::vector<std::string> &args) {
    int booleanSew = getBooleanSew(vlTypeInfo);
    auto vecVs2 =
        hasMask(op) ? op->opAttr & NoMaskedOff ? args[1] : args[2] : args[0];
    if (hasMask(op)) {
      auto vecM = args[0];
      os << first << " = __riscv_vfirst_m_b" << booleanSew << "_m(" << vecM << ", "
         << vecVs2 << ", vl);\n";
    } else {
      os << first << " = __riscv_vfirst_m_b" << booleanSew << "(" << vecVs2
         << ", vl);\n";
    }
  }
  void generateSingleOperatorCode() {
    auto output = op->outputs[0];
    getRawPointers(op->inputs, output);
    std::string counter = CodeGenForOperator::getCounter(os, loopLength);
    std::string first = getFirst(os);
    getLoopStart(counter, first);
    {
      getVL(counter);
      std::vector<std::string> args = getIntrinsicArguments();
      auto opResult = genOpString(os, op, args, output);
      storeResult(opResult);
      incrementRawPointerByVLEN();
      updateFirst(first, args);
    }
    getLoopEnd(counter);
  }
};

struct CodeGenForViota : CodeGenForOperator {
  CodeGenForViota() = delete;
  CodeGenForViota(std::ostream &os, OperatorBase *op, TypeInfo &typeInfo,
                  size_t length)
      : CodeGenForOperator(os, op, typeInfo, length) {}

  void storeResult(const std::string &opResult, std::string &accumulateMask,
                   std::vector<std::string> &args) {
    os << opResult << " = __riscv_vadd_vx_" << vlTypeInfo.shortVectorTypeName
       << getOpSuffix(op) + "(";
    if (hasNonmask(op)) {
      if (hasTU(op))
        os << args[0] << ", ";
    } else {
      auto vecM = args[0];
      auto vecMO = hasTAMA(op) ? "" : args[1];
      os << vecM << ", ";
      if (vecMO != "") {
        os << vecMO << ", ";
      }
    }
    os << opResult << ", " << "/* find what is accumulateMask:*/" << accumulateMask;

    if (haveTailPolicy(op)) {
      os << ", tail_vl);\n";
    } else {
      os << ", vl);\n";
    }
    storeVectorToOneD(os, opOutput.first, opResult, opOutput.second);
  }
  std::string getAccumulateMask() {
    std::string accumulateMask = getNewPlaceholderName();
    os << "unsigned " << accumulateMask << " = 0;\n";
    return accumulateMask;
  }
  void updateAccumulateMask(const std::string &accumulateMask,
                            std::vector<std::string> &args) {
    auto vecInputA = hasNonmask(op) ? hasTU(op) ? args[1] : args[0]
                     : hasTAMA(op) ? args[1]
                                    : args[2];
    if (hasNonmask(op))
      os << accumulateMask << " += __riscv_vcpop_m_b" << getBooleanSew(vlTypeInfo)
         << "(" << vecInputA << ", " << (haveTailPolicy(op) ? "tail_vl" : "vl")
         << ");\n";
    else {
      auto vecM = args[0];
      os << accumulateMask << " += __riscv_vcpop_m_b" << getBooleanSew(vlTypeInfo)
         << "_m(" << vecM << ", " << vecInputA << ", "
         << (haveTailPolicy(op) ? "tail_vl" : "vl") << ");\n";
    }
  }
  void generateSingleOperatorCode() {
    auto output = op->outputs[0];
    getRawPointers(op->inputs, output);
    std::string counter = CodeGenForOperator::getCounter(os, loopLength);
    std::string accumulateMask = getAccumulateMask();
    CodeGenForOperator::getLoopStart(os, counter);
    {
      if (haveTailPolicy(op)) {
        os << "vl = 2;\n";
        os << "size_t tail_vl = 1;\n";
      } else {
        getVL(counter);
      }
      std::vector<std::string> args = getIntrinsicArguments();
      auto opResult = genOpString(os, op, args, output);
      storeResult(opResult, accumulateMask, args);
      updateAccumulateMask(accumulateMask, args);
      incrementRawPointerByVLEN();
    }
    CodeGenForOperator::getLoopEnd(os);
  }
};

struct CodeGenForVid : CodeGenForOperator {
  CodeGenForVid() = delete;
  CodeGenForVid(std::ostream &os, OperatorBase *op, TypeInfo &typeInfo,
                size_t length)
      : CodeGenForOperator(os, op, typeInfo, length) {}

  void storeResult(const std::string &opResult, std::string &accumulateLength,
                   std::vector<std::string> &args) {
    os << opResult << " = __riscv_vadd_vx_" << vlTypeInfo.shortVectorTypeName
       << getOpSuffix(op) + "(";
    if (hasNonmask(op)) {
      if (hasTU(op))
        os << args[0] << ", ";
    } else {
      auto vecM = args[0];
      auto vecMO = hasTAMA(op) ? "" : args[1];
      os << vecM << ", ";
      if (vecMO != "") {
        os << vecMO << ", ";
      }
    }
    os << opResult << ", " << accumulateLength;

    if (haveTailPolicy(op)) {
      os << ", tail_vl);\n";
    } else {
      os << ", vl);\n";
    }
    storeVectorToOneD(os, opOutput.first, opResult, opOutput.second);
  }
  std::string getAccumulateLength() {
    std::string accumulateLength = getNewPlaceholderName();
    os << "unsigned " << accumulateLength << " = 0;\n";
    return accumulateLength;
  }
  void updateAccumulateLength(const std::string &accumulateLength) {
    os << accumulateLength << " += vl;\n";
  }
  void generateSingleOperatorCode() {
    auto output = op->outputs[0];
    getRawPointers(op->inputs, output);
    std::string counter = CodeGenForOperator::getCounter(os, loopLength);
    std::string accumulateLength = getAccumulateLength();
    CodeGenForOperator::getLoopStart(os, counter);
    {
      if (haveTailPolicy(op)) {
        os << "vl = 2;\n";
        os << "size_t tail_vl = 1;\n";
      } else {
        getVL(counter);
      }
      std::vector<std::string> args = getIntrinsicArguments();
      auto opResult = genOpString(os, op, args, output);
      storeResult(opResult, accumulateLength, args);
      updateAccumulateLength(accumulateLength);
      incrementRawPointerByVLEN();
    }
    CodeGenForOperator::getLoopEnd(os);
  }
};

static std::set<std::string> unitLoadTypeID = {
    "vle8_v",
    "vle16_v",
    "vle32_v",
    "vle64_v",
};

static std::set<std::string> unitStoreTypeID = {
    "vse8_v",
    "vse16_v",
    "vse32_v",
    "vse64_v",
};

static std::set<std::string> stridedLoadTypeID = {
    "vlse8_v",
    "vlse16_v",
    "vlse32_v",
    "vlse64_v",
};

static std::set<std::string> stridedStoreTypeID = {
    "vsse8_v",
    "vsse16_v",
    "vsse32_v",
    "vsse64_v",
};

static std::set<std::string> indexedLoadTypeID = {
    "vluxei8_v", "vluxei16_v", "vluxei32_v", "vluxei64_v",
    "vloxei8_v", "vloxei16_v", "vloxei32_v", "vloxei64_v",
};

static std::set<std::string> indexedStoreTypeID = {
    "vsuxei8_v", "vsuxei16_v", "vsuxei32_v", "vsuxei64_v",
    "vsoxei8_v", "vsoxei16_v", "vsoxei32_v", "vsoxei64_v",
};

struct CodeGenForLoadStore : CodeGenForOperator {
  enum LoadStoreType {
    Le,
    Se, // unit-stride load / store
    Lxei,
    Sxei, // indexed load / store
    Lse,
    Sse, // strided load / store
  };

  CodeGenForLoadStore() = delete;
  CodeGenForLoadStore(std::ostream &os, OperatorBase *op, TypeInfo &typeInfo,
                      size_t length)
      : CodeGenForOperator(os, op, typeInfo, length) {

    if (unitLoadTypeID.count(op->typeID)) {
      type = Le;
    } else if (unitStoreTypeID.count(op->typeID)) {
      type = Se;
    } else if (indexedLoadTypeID.count(op->typeID)) {
      type = Lxei;
    } else if (indexedStoreTypeID.count(op->typeID)) {
      type = Sxei;
    } else if (stridedLoadTypeID.count(op->typeID)) {
      type = Lse;
    } else if (stridedStoreTypeID.count(op->typeID)) {
      type = Sse;
    } else {
      assert(false && "[CodeGenForLoadStore] Unknown typeID");
    }
  }

  LoadStoreType type;

  bool isStoreType() const {
    return type == LoadStoreType::Se || type == LoadStoreType::Sxei ||
           type == LoadStoreType::Sse;
  }
  bool isLoadType() const {
    return type == LoadStoreType::Le || type == LoadStoreType::Lxei ||
           type == LoadStoreType::Lse;
  }

  std::vector<std::string> getUnitStrideArguments() {
    std::vector<std::string> ret;
    if (hasMask(op)) {
      auto inputM = opInputs[0]; // mask
      ret.push_back(loadOneDToVector(os, inputM.second, inputM.first, op));
      if (isLoadType() && !(op->opAttr & NoMaskedOff)) { // non-tama load
        auto inputMO = opInputs[1];                      // maskedoff
        ret.push_back(loadOneDToVector(os, inputMO.second, inputMO.first, op));
      }
    } else if (isLoadType() && hasTU(op)) { // tu load
      auto inputMO = opInputs[0];           // maskedoff
      ret.push_back(loadOneDToVector(os, inputMO.second, inputMO.first, op));
    }
    if (isLoadType()) {
      auto inputBase =
          hasMask(op) ? op->opAttr & NoMaskedOff ? opInputs[1] : opInputs[2]
          : hasTU(op) ? opInputs[1]
                      : opInputs[0];
      ret.push_back(inputBase.first);
    } else {
      ret.push_back(opOutput.first);
      auto inputVal = hasMask(op) ? opInputs[1] : opInputs[0];
      ret.push_back(loadOneDToVector(os, inputVal.second, inputVal.first, op));
    }
    return ret;
  }

  std::vector<std::string> getIndexArguments() {
    std::vector<std::string> ret;
    if (hasMask(op)) {
      auto inputM = opInputs[0]; // mask
      ret.push_back(loadOneDToVector(os, inputM.second, inputM.first, op));
      if (isLoadType() &&
          !(op->opAttr & NoMaskedOff)) { // non-tama indexed load
        auto inputMO = opInputs[1];      // maskedoff
        ret.push_back(loadOneDToVector(os, inputMO.second, inputMO.first, op));
      }
    } else if (isLoadType() && hasTU(op)) { // tu load
      auto inputMO = opInputs[0];           // maskedoff
      ret.push_back(loadOneDToVector(os, inputMO.second, inputMO.first, op));
    }

    std::pair<std::string, ValueBase *> inputIdx =
        isLoadType() ? (hasMask(op) ? op->opAttr & NoMaskedOff ? opInputs[2]
                                                               : opInputs[3]
                        : hasTU(op) ? opInputs[2]
                                    : opInputs[1])
                     : (hasMask(op) ? opInputs[2] : opInputs[1]);

    // Adjust LMUL for index
    int opSew = op->typeInfo->sew.to_int();
    int idxSew = inputIdx.second->typeInfo->sew.to_int();
    if (opSew > idxSew) {
      TypeInfo *updateTypeInfo = op->typeInfo;
      while (opSew > idxSew) {
        updateTypeInfo = TypeInfo::getNarrowed(
            *updateTypeInfo, inputIdx.second->typeInfo->typeClass);
        opSew /= 2;
      }
      inputIdx.second->typeInfo = updateTypeInfo;
    }
    if (opSew < idxSew) {
      TypeInfo *updateTypeInfo = op->typeInfo;
      while (opSew < idxSew) {
        updateTypeInfo = TypeInfo::getWidened(
            *updateTypeInfo, inputIdx.second->typeInfo->typeClass);
        opSew *= 2;
      }
      inputIdx.second->typeInfo = updateTypeInfo;
    }

    std::string vecIdx =
        loadOneDToVector(os, inputIdx.second, inputIdx.first, op);
    if (isLoadType()) {
      auto inputBase =
          hasMask(op) ? op->opAttr & NoMaskedOff ? opInputs[1] : opInputs[2]
          : hasTU(op) ? opInputs[1]
                      : opInputs[0];
      ret.push_back(inputBase.first);
      ret.push_back(vecIdx);
    } else {
      auto inputVal = hasMask(op) ? opInputs[1] : opInputs[0];
      ret.push_back(opOutput.first);
      ret.push_back(vecIdx);
      ret.push_back(loadOneDToVector(os, inputVal.second, inputVal.first, op));
    }

    // Calculate remainder for inputIdx
    // If length is always safe, we don't need to calculate the remainder
    if (inputIdx.second->typeInfo->sew.to_int() != 64) {
      os << "if (" << opOutput.second->length << " < "
         << (1ull << inputIdx.second->typeInfo->sew.to_int()) - 1 << ") {\n";
    } else {
      os << "{\n";
    }
    {
      if (hasMask(op)) {
        auto vecM = ret[0];
        auto vecZero = getVectorFromConstant(os, 0, *inputIdx.second->typeInfo);
        os << vecIdx << " = __riscv_vremu_vx_"
           << inputIdx.second->typeInfo->shortVectorTypeName;
        os << "_m(" << vecM <<  ", " << vecIdx << ", "
           << opOutput.second->length << ", vl);\n";
      } else {
        os << vecIdx << " = __riscv_vremu_vx_"
           << inputIdx.second->typeInfo->shortVectorTypeName;
        os << "(" << vecIdx << ", " << opOutput.second->length << ", vl);\n";
      }
    }
    os << "}\n";

    // Align the index with sew of the operator
    os << vecIdx << " = __riscv_vmul_vx_"
       << inputIdx.second->typeInfo->shortVectorTypeName << "(" << vecIdx
       << ", " << op->typeInfo->sew.to_int() / 8 << ", vl);\n";

    return ret;
  }

  std::vector<std::string> getStrideArguments() {
    std::vector<std::string> ret;
    if (hasMask(op)) {
      auto inputM = opInputs[0]; // mask
      ret.push_back(loadOneDToVector(os, inputM.second, inputM.first, op));
      if (isLoadType() &&
          !(op->opAttr & NoMaskedOff)) { // tama doesn't have maskedoff
        auto inputMO = opInputs[1];      // maskedoff
        ret.push_back(loadOneDToVector(os, inputMO.second, inputMO.first, op));
      }
    } else if (isLoadType() && hasTU(op)) { // strided load for tu
      auto inputMO = opInputs[0];           // maskedoff
      ret.push_back(loadOneDToVector(os, inputMO.second, inputMO.first, op));
    }

    if (isLoadType()) {
      auto inputBase =
          hasMask(op) ? op->opAttr & NoMaskedOff ? opInputs[1] : opInputs[2]
          : hasTU(op) ? opInputs[1]
                      : opInputs[0];
      auto inputStride =
          hasMask(op) ? op->opAttr & NoMaskedOff ? opInputs[2] : opInputs[3]
          : hasTU(op) ? opInputs[2]
                      : opInputs[1];
      ret.push_back(inputBase.first);
      ret.push_back(inputStride.first);
    } else {
      auto inputStride = hasMask(op) ? opInputs[2] : opInputs[1];
      auto inputVal = hasMask(op) ? opInputs[1] : opInputs[0];
      ret.push_back(opOutput.first);
      ret.push_back(inputStride.first);
      ret.push_back(loadOneDToVector(os, inputVal.second, inputVal.first, op));
    }

    return ret;
  }

  std::vector<std::string> getIntrinsicArguments(const LoadStoreType &type) {
    if (type == Le || type == Se)
      return getUnitStrideArguments();
    else if (type == Lxei || type == Sxei)
      return getIndexArguments();
    else if (type == Lse || type == Sse)
      return getStrideArguments();
    else
      assert(false); // unreachable
  }

  void storeResult(std::string opResult, std::vector<std::string> &args) {
    if (isLoadType())
      storeVectorToOneD(os, opOutput.first, opResult, opOutput.second);
    else if (isStoreType()) {
    } else
      assert(false);
  }

  void incrementRawPointerByVLEN() {
    int skipBaseAddress = -1;
    int increaseBaseAddressByStrideVlen = -1;
    if (type == Lxei)
      skipBaseAddress = hasMask(op) ? op->opAttr & NoMaskedOff ? 1 : 2
                        : hasTU(op) ? 1
                                    : 0;
    if (type == Lse) {
      increaseBaseAddressByStrideVlen = hasMask(op)
                                            ? op->opAttr & NoMaskedOff ? 1 : 2
                                        : hasTU(op) ? 1
                                                    : 0;
    }
    for (int i = 0; i < opInputs.size(); ++i) {
      if (i == skipBaseAddress)
        continue;
      auto input = opInputs[i];
      std::string &rawID = input.first;
      ValueBase *value = input.second;
      if (i == increaseBaseAddressByStrideVlen) {
        auto strideID = hasMask(op) ? op->opAttr & NoMaskedOff
                                          ? opInputs[2].first
                                          : opInputs[3].first
                        : hasTU(op) ? opInputs[2].first
                                    : opInputs[1].first;
        os << rawID << " += vl * " << strideID << ";\n";
        continue;
      }
      if (isScalarValue(value))
        continue;
      RIF::incrementRawPointerByVLEN(os, rawID);
    }
    if (type == Sse) {
      auto strideID = hasMask(op) ? opInputs[2].first : opInputs[1].first;
      os << opOutput.first << " += vl * " << strideID << ";\n";
    } else if (isOneDValue(opOutput.second) && type != Sxei)
      RIF::incrementRawPointerByVLEN(os, opOutput.first);
  }

  void generateSingleOperatorCode() {
    auto output = op->outputs[0];
    getRawPointers(op->inputs, output);
    if (type == Se || type == Sxei || type == Lse || type == Sse) {
      auto rawOut = getRawPointerString(os, output);
      std::string counter = CodeGenForOperator::getCounter(os, loopLength);
      CodeGenForOperator::getLoopStart(os,
                                       counter); // init destinations to zero
      {
        getVL(counter);
        std::string vecZero =
            getVectorFromConstant(os, 0, *opOutput.second->typeInfo);
        storeVectorToOneD(os, rawOut, vecZero, opOutput.second);
        RIF::incrementRawPointerByVLEN(os, rawOut);
      }
      CodeGenForOperator::getLoopEnd(os);
    }

    if (type == Lse) { // strided load
      auto inputStride =
          hasMask(op) ? op->opAttr & NoMaskedOff ? opInputs[2] : opInputs[3]
          : hasTU(op) ? opInputs[2]
                      : opInputs[1];
      auto strideID = inputStride.first;
      os << strideID << " = (" << strideID << " % 4) + 1;\n";

      auto stride = *static_cast<ScalarIntXLenVal *>(inputStride.second)->ptr;
      if (stride < 0) {
        auto inputBase =
            hasMask(op) ? op->opAttr & NoMaskedOff ? opInputs[1] : opInputs[2]
            : hasTU(op) ? opInputs[1]
                        : opInputs[0];
        auto baseAddr = inputBase.first;
        os << baseAddr << " += " << inputBase.second->length << " - 1;\n";
      }
    }
    if (type == Sse) { // strided store
      auto inputStride = hasMask(op) ? opInputs[2] : opInputs[1];
      auto strideID = inputStride.first;
      os << strideID << " = (" << strideID << " % 4) + 1;\n";

      auto stride = *static_cast<ScalarIntXLenVal *>(inputStride.second)->ptr;
      if (stride < 0) {
        auto outputBaseAddr = opOutput.first;
        os << outputBaseAddr << " += " << opOutput.second->length << " - 1;\n";
      }
    }

    std::string counter = CodeGenForOperator::getCounter(os, loopLength);
    std::string tripCounter = getNewPlaceholderName();
    os << "size_t " << tripCounter << " = 0;\n";
    CodeGenForOperator::getLoopStart(os, counter);
    {
      if (haveTailPolicy(op)) {
        os << "vl = 2;\n";
        os << "size_t tail_vl = 1;\n";
      } else {
        getVL(counter);
      }
      std::vector<std::string> args = getIntrinsicArguments(type);
      if (type == Sse) {
        auto inputStride = hasMask(op) ? opInputs[2] : opInputs[1];
        auto stride = inputStride.second;
        std::string strideID = inputStride.first;
        auto storeBase = opOutput.first;
        os << "if (" << tripCounter << " < " << op->inputs[0]->length
           << ") {\n";
        {
          // std::string saveVL = getNewPlaceholderName();

          // os << "size_t " << saveVL << " = vl;\n";
          os << "vl = vl < (" << op->inputs[0]->length << " - " << tripCounter
             << " + " << strideID << " - 1) / " << strideID << " ? \n";
          os << "vl : (" << op->inputs[0]->length << " - " << tripCounter
             << " + " << strideID << " - 1) / " << strideID << ";\n";

          std::string saveStride = getNewPlaceholderName();
          os << stride->typeInfo->scalarTypeName << " " << saveStride << " = "
             << strideID << ";\n";
          os << strideID << " *= " << op->typeInfo->sew.to_int() / 8 << ";\n";

          auto opResult = genOpString(os, op, args, output);
          // storeResult(opResult, args);

          // os << "vl = " << saveVL << "; // recover vl\n";
          os << strideID << " = " << saveStride << "; // recover stride\n";
        }
        os << "}\n";
        os << "else {}\n";
      } else if (type == Lse) {
        auto inputStride =
            hasMask(op) ? op->opAttr & NoMaskedOff ? opInputs[2] : opInputs[3]
            : hasTU(op) ? opInputs[2]
                        : opInputs[1];
        auto stride = inputStride.second;
        std::string strideID = inputStride.first;
        auto storeBase = opOutput.first;
        os << "if (" << tripCounter << " < " << op->inputs[0]->length
           << ") {\n";
        {
          auto vecZero = getVectorFromConstant(os, 0, *output->typeInfo);
          storeVectorToOneD(os, storeBase, vecZero, output);
          std::string saveVL = getNewPlaceholderName();

          os << "size_t " << saveVL << " = vl;\n";
          os << "vl = vl < (" << op->inputs[0]->length << " - " << tripCounter
             << " + " << strideID << " - 1) / " << strideID << " ? \n";
          os << "vl : (" << op->inputs[0]->length << " - " << tripCounter
             << " + " << strideID << " - 1) / " << strideID << ";\n";

          std::string saveStride = getNewPlaceholderName();
          os << stride->typeInfo->scalarTypeName << " " << saveStride << " = "
             << strideID << ";\n";
          os << strideID << " *= " << op->typeInfo->sew.to_int() / 8 << ";\n";

          auto opResult = genOpString(os, op, args, output);
          storeResult(opResult, args);

          os << "vl = " << saveVL << "; // recover vl\n";
          os << strideID << " = " << saveStride << "; // recover stride\n";
        }
        os << "}\n";
        os << "else {\n";
        {
          auto vecZero = getVectorFromConstant(os, 0, *output->typeInfo);
          
          
          storeVectorToOneD(os, storeBase, vecZero, output);
        }
        os << "};\n";
      } else {
        auto opResult = genOpString(os, op, args, output);
        storeResult(opResult, args);
      }
      incrementRawPointerByVLEN();
      if (type == Lse) {
        std::string strideID =
            hasMask(op)   ? op->opAttr & NoMaskedOff ? args[2] : args[3]
              : (hasTU(op)) ? args[2]
                          : args[1];
        os << tripCounter << " += vl * " << strideID << ";\n";
      }
      if (type == Sse) {
        std::string strideID = hasMask(op) ? args[2] : args[1];
        os << tripCounter << " += vl * " << strideID << ";\n";
      }
    }
    CodeGenForOperator::getLoopEnd(os);
  }
};

// Single input operator (e.g. op_id with suffux _v, _f, _x, ...)
static void generateVOperatorCode(std::ostream &os, OperatorBase *op) {
  ValueBase *vd = getVd(op);
  ValueBase *maskedoff = getMaskedoff(op);
  ValueBase *vs2 = getVs2(op);
  assert(getVs1(op) == nullptr);
  assert(vd != nullptr);
  std::cerr << "op:" << op -> typeID;
  assert(vs2 != nullptr);

  CodeGenForOperator codegen(os, op, *op->typeInfo, vd->length);
  codegen.generateSingleOperatorCode();
}

static void generateLoadStoreOperatorCode(std::ostream &os, OperatorBase *op) {
  ValueBase *vd = getVd(op);
  assert(vd != nullptr);

  CodeGenForLoadStore codegen(os, op, *op->typeInfo, vd->length);
  codegen.generateSingleOperatorCode();
}

// Nonmasked VV / VX operation
static void generateVVOrVXOperatorCode(std::ostream &os, OperatorBase *op) {
  ValueBase *vd = getVd(op);
  ValueBase *maskedoff = getMaskedoff(op);
  ValueBase *vs2 = getVs2(op);
  ValueBase *vs1 = getVs1(op);
  assert(vs2 != nullptr);
  assert(vs1 != nullptr);
  assert(vd != nullptr);

  CodeGenForOperator codegen(os, op, *vs2->typeInfo, vd->length);
  codegen.generateSingleOperatorCode();
}

static void generateMulAddOperatorCode(std::ostream &os, OperatorBase *op) {
  ValueBase *vd = getVd(op);
  ValueBase *maskedoff = getMaskedoff(op);
  ValueBase *vs2 = getVs2(op);
  ValueBase *vs1 = getVs1(op);
  if (!(op->opAttr & NoMaskedOff))
    assert(maskedoff != nullptr);
  assert(vs2 != nullptr);
  assert(vs1 != nullptr);
  assert(vd != nullptr);

  CodeGenForOperator codegen(os, op, *vs2->typeInfo, vd->length);
  codegen.generateSingleOperatorCode();
}

static void generateMulAddRMOperatorCode(std::ostream &os, OperatorBase *op) {
  ValueBase *vd = getVd(op);
  ValueBase *maskedoff = getMaskedoff(op);
  ValueBase *vs2 = getVs2(op);
  ValueBase *vs1 = getVs1(op);
  if (!(op->opAttr & NoMaskedOff))
    assert(maskedoff != nullptr);
  assert(vs2 != nullptr);
  assert(vs1 != nullptr);
  assert(vd != nullptr);

  CodeGenForOperator codegen(os, op, *vs2->typeInfo, vd->length);
  codegen.generateSingleOperatorCode();
}

// Operators with suffix vvm / vxm / vfm
static void generateVVMVXMOperatorCode(std::ostream &os, OperatorBase *op) {
  ValueBase *vs2 = getVs2(op);
  assert(vs2 != nullptr);

  CodeGenForOperator codegen(os, op, *vs2->typeInfo, op->outputs[0]->length);
  codegen.generateSingleOperatorCode();
}

// Operators with suffix vf2 / vf4 / vf8
static void generateExtensionOperatorCode(std::ostream &os, OperatorBase *op) {
  ValueBase *vd = getVd(op);
  ValueBase *maskedoff = getMaskedoff(op);
  ValueBase *vs2 = getVs2(op);
  ValueBase *vs1 = getVs1(op);
  assert(vd != nullptr);
  assert(vs2 != nullptr);
  assert(vs1 == nullptr);

  CodeGenForOperator codegen(os, op, *op->typeInfo, vd->length);
  codegen.generateSingleOperatorCode();
}

// Operators with suffix vs
// These are reduction ops and require specialized code gen
static void generateVSOperatorCode(std::ostream &os, OperatorBase *op) {
  ValueBase *vd = getVd(op);
  ValueBase *vs2 = getVs2(op);

  CodeGenForReductionOperator codegen(os, op, *op->typeInfo, vs2->length);
  codegen.generateSingleOperatorCode();
}

// Operators with suffix mm / m
static void generateMMOrMOperatorCode(std::ostream &os, OperatorBase *op) {
  auto output = op->outputs[0];

  TypeInfo typeInfo = *op->typeInfo;
  size_t length = output->length;

  CodeGenForOperator codegen(os, op, typeInfo, length);
  codegen.generateSingleOperatorCode();
}

static void generateVcpopOperatorCode(std::ostream &os, OperatorBase *op) {
  auto output = op->outputs[0];

  TypeInfo typeInfo = *op->typeInfo;
  size_t length = op->inputs[0]->length;

  CodeGenForVcpop codegen(os, op, typeInfo, length);
  codegen.generateSingleOperatorCode();
}

static void generateVfirstOperatorCode(std::ostream &os, OperatorBase *op) {
  auto output = op->outputs[0];

  TypeInfo typeInfo = *op->typeInfo;
  size_t length = op->inputs[0]->length;

  CodeGenForVfirst codegen(os, op, typeInfo, length);
  codegen.generateSingleOperatorCode();
}

static void generateVmsbfVmsifVmsofOperatorCode(std::ostream &os,
                                                OperatorBase *op) {
  auto output = op->outputs[0];

  TypeInfo typeInfo = *op->typeInfo;
  size_t length = op->inputs[0]->length;

  CodeGenForVmsbfVmsifVmsof codegen(os, op, typeInfo, length);
  codegen.generateSingleOperatorCode();
}

static void generateViotaOperatorCode(std::ostream &os, OperatorBase *op) {
  auto typeInfo = *op->typeInfo;
  auto length = op->outputs[0]->length;

  CodeGenForViota codegen(os, op, typeInfo, length);
  codegen.generateSingleOperatorCode();
}

static void generateVidOperatorCode(std::ostream &os, OperatorBase *op) {
  auto typeInfo = *op->typeInfo;
  auto length = op->outputs[0]->length;

  CodeGenForVid codegen(os, op, typeInfo, length);
  codegen.generateSingleOperatorCode();
}

static void generateOperatorCode(std::ostream &os, OperatorBase *op) {
  if (!hasMask(op) && !hasNonmask(op))
    assert(false && "Masking attribute not set");

  std::string typeID = op->typeID;
  std::string operandType = typeID.substr(typeID.find("_") + 1);

  if (operandType == "vv" || operandType == "wv" || operandType == "vx" ||
      operandType == "wx" || operandType == "vf" || operandType == "wf") {
    if (op->opAttr & MulAddOperation)
      if (op->opAttr & FRM)
        generateMulAddRMOperatorCode(os, op);
      else
        generateMulAddOperatorCode(os, op);
    else
      generateVVOrVXOperatorCode(os, op);
  } else if (operandType == "mm") {
    if (hasMask(op))
      assert(false);
    else
      generateMMOrMOperatorCode(os, op);
  } else if (operandType == "m") {
    if (typeID == "vcpop_m")
      generateVcpopOperatorCode(os, op);
    else if (typeID == "vfirst_m")
      generateVfirstOperatorCode(os, op);
    else if (typeID == "vmsbf_m" || typeID == "vmsif_m" || typeID == "vmsof_m")
      generateVmsbfVmsifVmsofOperatorCode(os, op);
    else if (typeID == "viota_m")
      generateViotaOperatorCode(os, op);
    else if (hasMask(op)) {
      assert(false && "No mask operations for _m suffix");
    } else
      generateMMOrMOperatorCode(os, op);
  } else if (ends_with(typeID, "_v") || ends_with(typeID, "_x") ||
             ends_with(typeID, "_w") || ends_with(typeID, "_f")) {
    if (typeID == "vid_v")
      generateVidOperatorCode(os, op);
    else if (op->opAttr & LoadOperation || op->opAttr & StoreOperation)
      generateLoadStoreOperatorCode(os, op);
    else
      generateVOperatorCode(os, op);
  } else if (operandType == "vvm" || operandType == "vfm" ||
             operandType == "vxm") {
    generateVVMVXMOperatorCode(os, op);
  } else if (operandType == "vf2" || operandType == "vf4" ||
             operandType == "vf8") {
    generateExtensionOperatorCode(os, op);
  } else if (operandType == "vs") {
    generateVSOperatorCode(os, op);
  } else {
    std::cerr << "Encounter unknown operand type\n";
    exit(1);
  }
}

#define CUSTOM_OP_TYPE(OP_TYPE, OP_ID, SEW, TYPE_CLASS, OP_ATTR, OUTPUT_TYPE,  \
                       NUM_OF_INPUTS, ...)                                     \
  void OP_TYPE##Op::generateData() { compute##OP_TYPE##Op(this); }             \
  void OP_TYPE##Op::generateCCode(std::ostream &os) {                          \
    generateOperatorCode(os, this);                                            \
  }
#include "CustomOperator.def"
#undef CUSTOM_OP_TYPE

template <typename OneDT>
static void emitOneDVerificationCode(std::ostream &os, OperatorBase *op,
                                     ValueBase *output) {
  auto scalarOutput = static_cast<OneDT *>(output);
  auto length = scalarOutput->length;
  auto dataOut = getRawPointer(scalarOutput);

  os << output->dataTypeID << " tmp[] = {";
  for (int i = 0; i < length; ++i) {
    if (output->dt == DataTypeEnum::Int8_t) {
      os << std::to_string((int8_t)dataOut[i]);
    } else if (output->dt == DataTypeEnum::Int16_t) {
      os << std::to_string((int16_t)dataOut[i]);
    } else if (output->dt == DataTypeEnum::Int32_t) {
      os << std::to_string((int32_t)dataOut[i]);
    } else if (output->dt == DataTypeEnum::Int64_t) {
      os << std::to_string((int64_t)dataOut[i]);
    } else if (output->dt == DataTypeEnum::Uint8_t) {
      os << std::to_string((uint8_t)dataOut[i]);
    } else if (output->dt == DataTypeEnum::Uint16_t) {
      os << std::to_string((uint16_t)dataOut[i]);
    } else if (output->dt == DataTypeEnum::Uint32_t) {
      os << std::to_string((uint32_t)dataOut[i]);
    } else if (output->dt == DataTypeEnum::Uint64_t) {
      os << std::to_string((uint64_t)dataOut[i]);
    } else if (output->dt == DataTypeEnum::Ptrdiff_t) {
      os << std::to_string((long)dataOut[i]);
    } else if (output->dt == DataTypeEnum::Size_t) {
      os << std::to_string((unsigned long)dataOut[i]);
    } else {
      assert(false && "Unkown dataType");
    }

    if (output->dt == DataTypeEnum::Uint32_t)
      os << "u";
    if (output->dt == DataTypeEnum::Int64_t)
      os << "ll";
    if (output->dt == DataTypeEnum::Uint64_t)
      os << "ull";
    os << ",";
  }
  os << "};\n";

  os << "for (int i=0; i<" << length << ";++i)\n";
  os << "if(" << output->id << "[i] != tmp[i]) {\n\treturn 0;\n}\n";

  os << "\treturn 1;\n";
}

template <>
void emitOneDVerificationCode<OneDFloat16Val>(std::ostream &os,
                                              OperatorBase *op,
                                              ValueBase *output) {
  auto value = static_cast<OneDFloat16Val *>(output);
  auto length = value->length;
  float16_t *fp16 = getRawPointer(value);

  os << "uint64_t tmp[] = {";
  for (int i = 0; i < length; ++i) {
    os << std::to_string(fp16[i].v) << ",";
  }
  os << "};\n";

  os << "union { float16_t f16; uint16_t u16; } converter;\n";
  os << "union { float16_t f16; uint16_t u16; } converter2;\n";
  os << "for (int i=0; i<" << length << ";++i){\n";
  os << "converter.u16 = tmp[i];\n";
  os << "converter2.f16 = " << output->id << "[i];\n";
  os << "if(converter.f16 != converter2.f16 && !(isNaNF16UI(converter.u16) && "
        "isNaNF16UI(converter2.u16))) {\n";
  os << "return 0;\n}\n";
  os << "}\n";
  os << "return 1;\n";
}

template <>
void emitOneDVerificationCode<OneDFloat32Val>(std::ostream &os,
                                              OperatorBase *op,
                                              ValueBase *output) {
  auto value = static_cast<OneDFloat32Val *>(output);
  auto length = value->length;
  float32_t *fp32 = getRawPointer(value);

  os << "uint64_t tmp[] = {";
  for (int i = 0; i < length; ++i) {
    os << std::to_string(fp32[i].v) << "u,";
  }
  os << "};\n";

  os << "union { float32_t f32; uint32_t u32; } converter;\n";
  os << "union { float32_t f32; uint32_t u32; } converter2;\n";
  os << "for (int i=0; i<" << length << ";++i){\n";
  os << "converter.u32 = tmp[i];\n";
  os << "converter2.f32 = " << output->id << "[i];\n";
  os << "if(converter.f32 != converter2.f32 && !(isNaNF32UI(converter.u32) && "
        "isNaNF32UI(converter2.u32))) {\n";
  os << "return 0;\n}\n";
  os << "}\n";
  os << "return 1;\n";
}

template <>
void emitOneDVerificationCode<OneDFloat64Val>(std::ostream &os,
                                              OperatorBase *op,
                                              ValueBase *output) {
  auto value = static_cast<OneDFloat64Val *>(output);
  auto length = value->length;
  float64_t *fp64 = getRawPointer(value);

  os << "uint64_t tmp[] = {";
  for (int i = 0; i < length; ++i) {
    os << std::to_string(fp64[i].v) << "ull,";
  }
  os << "};\n";

  os << "union { float64_t f64; uint64_t u64; } converter;\n";
  os << "union { float64_t f64; uint64_t u64; } converter2;\n";
  os << "for (int i=0; i<" << length << ";++i){\n";
  os << "converter.u64 = tmp[i];\n";
  os << "converter2.f64 = " << output->id << "[i];\n";
  os << "if(converter.f64 != converter2.f64 && !(isNaNF64UI(converter.u64) && "
        "isNaNF64UI(converter2.u64))) {\n";
  os << "return 0;\n}\n";
  os << "}\n";
  os << "return 1;\n";
}
template <typename ScalarT>
static void emitScalarVerificationCode(std::ostream &os, OperatorBase *op,
                                       ValueBase *output) {
  auto scalarOutput = static_cast<ScalarT *>(output);
  auto dataOut = getRawPointer(scalarOutput);

  os << output->dataTypeID << " tmp = ";
  if (output->dt == DataTypeEnum::Int8_t) {
    os << std::to_string((int8_t)*dataOut);
  } else if (output->dt == DataTypeEnum::Int16_t) {
    os << std::to_string((int16_t)*dataOut);
  } else if (output->dt == DataTypeEnum::Int32_t) {
    os << std::to_string((int32_t)*dataOut);
  } else if (output->dt == DataTypeEnum::Int64_t) {
    os << std::to_string((int64_t)*dataOut);
  } else if (output->dt == DataTypeEnum::Uint8_t) {
    os << std::to_string((uint8_t)*dataOut);
  } else if (output->dt == DataTypeEnum::Uint16_t) {
    os << std::to_string((uint16_t)*dataOut);
  } else if (output->dt == DataTypeEnum::Uint32_t) {
    os << std::to_string((uint32_t)*dataOut);
  } else if (output->dt == DataTypeEnum::Uint64_t) {
    os << std::to_string((uint64_t)*dataOut);
  } else if (output->dt == DataTypeEnum::Ptrdiff_t) {
    os << std::to_string((long)*dataOut);
  } else if (output->dt == DataTypeEnum::Size_t) {
    os << std::to_string((unsigned long)*dataOut);
  } else {
    assert(false && "Unkown dataType");
  }

  if (output->dt == DataTypeEnum::Int64_t)
    os << "ll";
  if (output->dt == DataTypeEnum::Uint64_t)
    os << "ull";

  os << ";\n";

  os << "if(" << output->id << " != tmp) {\n";
  os << "return 0;\n}\n";

  os << "return 1;\n";
}

template <>
void emitScalarVerificationCode<ScalarFloat16Val>(std::ostream &os,
                                                  OperatorBase *op,
                                                  ValueBase *output) {
  auto scalarOutput = static_cast<ScalarFloat16Val *>(output);
  float16_t *dataOut = getRawPointer(scalarOutput);
  
  os << "uint16_t tmp = " << std::to_string(dataOut->v) << ";\n";
  os << "union { float16_t f16; uint16_t u16; } converter, converter2;\n";
  os << "converter.u16 = tmp;\n";
  os << "converter2.f16 = " << output->id << ";\n";
  os << "if(converter.f16 != " << output->id
     << " && !(isNaNF16UI(converter.u16) && isNaNF16UI(converter2.u16))) {\n";
  os << "return 0;\n}\n";
  os << "return 1;\n";
}

template <>
void emitScalarVerificationCode<ScalarFloat32Val>(std::ostream &os,
                                                  OperatorBase *op,
                                                  ValueBase *output) {
  auto scalarOutput = static_cast<ScalarFloat32Val *>(output);
  auto dataOut = getRawPointer(scalarOutput);

  os << "uint32_t tmp = " << std::to_string(dataOut->v) << "u;\n";
  os << "union { float32_t f32; uint32_t u32; } converter, converter2;\n";
  os << "converter.u32 = tmp;\n";
  os << "converter2.f32 = " << output->id << ";\n";
  os << "if(converter.f32 != " << output->id
     << " && !(isNaNF32UI(converter.u32) && isNaNF32UI(converter2.u32))) {\n";
  os << "return 0;\n}\n";
  os << "return 1;\n";
}

template <>
void emitScalarVerificationCode<ScalarFloat64Val>(std::ostream &os,
                                                  OperatorBase *op,
                                                  ValueBase *output) {
  auto scalarOutput = static_cast<ScalarFloat64Val *>(output);
  auto dataOut = getRawPointer(scalarOutput);

  os << "uint64_t tmp = " << std::to_string(dataOut->v) << "ull;\n";
  os << "union { float64_t f64; uint64_t u64; } converter, converter2;\n";
  os << "converter.u64 = tmp;\n";
  os << "converter2.f64 = " << output->id << ";\n";
  os << "if(converter.f64 != " << output->id
     << " && !(isNaNF64UI(converter.u64) && isNaNF64UI(converter2.u64))) {\n";
  os << "return 0;\n}\n";
  os << "return 1;\n";
}

void generateVerificationCode(std::ostream &os, OperatorBase *op) {
  if (op->type == Initialize) {
    os << "return 1;\n";
    return;
  }
  auto output = op->outputs[0];
  auto type = output->type;

#define CUSTOM_ONE_D_TYPE(CUSTOM_NAME, ...)                                    \
  if (type == OneD##CUSTOM_NAME) {                                             \
    emitOneDVerificationCode<OneD##CUSTOM_NAME##Val>(os, op, output);          \
    return;                                                                    \
  }
#include "CustomValue.def"
#undef CUSTOM_ONE_D_TYPE
#undef CUSTOM_SCALAR_TYPE

#define CUSTOM_SCALAR_TYPE(CUSTOM_NAME, ...)                                   \
  if (type == Scalar##CUSTOM_NAME) {                                           \
    emitScalarVerificationCode<Scalar##CUSTOM_NAME##Val>(os, op, output);      \
    return;                                                                    \
  }
#include "CustomValue.def"
#undef CUSTOM_ONE_D_TYPE
#undef CUSTOM_SCALAR_TYPE

  assert(false && "output type is not recognized");
}

} // namespace RIF
